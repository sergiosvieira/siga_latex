\section{Referência da Template de Classe tree$<$ T, tree\+\_\+node\+\_\+allocator $>$}
\label{classtree}\index{tree$<$ T, tree\+\_\+node\+\_\+allocator $>$@{tree$<$ T, tree\+\_\+node\+\_\+allocator $>$}}


{\ttfamily \#include $<$tree.\+h$>$}

\subsection*{Componentes}
\begin{DoxyCompactItemize}
\item 
class {\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Breadth-\/first iterator, using a queue. \end{DoxyCompactList}\item 
class {\bf fixed\+\_\+depth\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Iterator which traverses only the nodes at a given depth from the root. \end{DoxyCompactList}\item 
class {\bf iterator\+\_\+base}
\begin{DoxyCompactList}\small\item\em Base class for iterators, only pointers stored, no traversal logic. \end{DoxyCompactList}\item 
class {\bf iterator\+\_\+base\+\_\+less}
\begin{DoxyCompactList}\small\item\em Comparator class for iterators (compares pointer values; why doesn\textquotesingle{}t this work automatically?) \end{DoxyCompactList}\item 
class {\bf leaf\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Iterator which traverses only the leaves. \end{DoxyCompactList}\item 
class {\bf post\+\_\+order\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Depth-\/first iterator, first accessing the children, then the node itself. \end{DoxyCompactList}\item 
class {\bf pre\+\_\+order\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Depth-\/first iterator, first accessing the node, then its children. \end{DoxyCompactList}\item 
class {\bf sibling\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em Iterator which traverses only the nodes which are siblings of each other. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Tipos Públicos}
\begin{DoxyCompactItemize}
\item 
typedef T {\bf value\+\_\+type}
\begin{DoxyCompactList}\small\item\em Value of the data stored at a node. \end{DoxyCompactList}\item 
typedef {\bf pre\+\_\+order\+\_\+iterator} {\bf iterator}
\begin{DoxyCompactList}\small\item\em The default iterator types throughout the tree class. \end{DoxyCompactList}\item 
typedef {\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf breadth\+\_\+first\+\_\+iterator}
\end{DoxyCompactItemize}
\subsection*{Métodos Públicos}
\begin{DoxyCompactItemize}
\item 
{\bf tree} ()
\item 
{\bf tree} (const T \&)
\item 
{\bf tree} (const {\bf iterator\+\_\+base} \&)
\item 
{\bf tree} (const {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&)
\item 
{\bf $\sim$tree} ()
\item 
{\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \& {\bf operator=} (const {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&)
\item 
{\bf pre\+\_\+order\+\_\+iterator} {\bf begin} () const 
\begin{DoxyCompactList}\small\item\em Return iterator to the beginning of the tree. \end{DoxyCompactList}\item 
{\bf pre\+\_\+order\+\_\+iterator} {\bf end} () const 
\begin{DoxyCompactList}\small\item\em Return iterator to the end of the tree. \end{DoxyCompactList}\item 
{\bf post\+\_\+order\+\_\+iterator} {\bf begin\+\_\+post} () const 
\begin{DoxyCompactList}\small\item\em Return post-\/order iterator to the beginning of the tree. \end{DoxyCompactList}\item 
{\bf post\+\_\+order\+\_\+iterator} {\bf end\+\_\+post} () const 
\begin{DoxyCompactList}\small\item\em Return post-\/order end iterator of the tree. \end{DoxyCompactList}\item 
{\bf fixed\+\_\+depth\+\_\+iterator} {\bf begin\+\_\+fixed} (const {\bf iterator\+\_\+base} \&, unsigned int) const 
\begin{DoxyCompactList}\small\item\em Return fixed-\/depth iterator to the first node at a given depth from the given iterator. \end{DoxyCompactList}\item 
{\bf fixed\+\_\+depth\+\_\+iterator} {\bf end\+\_\+fixed} (const {\bf iterator\+\_\+base} \&, unsigned int) const 
\begin{DoxyCompactList}\small\item\em Return fixed-\/depth end iterator. \end{DoxyCompactList}\item 
{\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf begin\+\_\+breadth\+\_\+first} () const 
\begin{DoxyCompactList}\small\item\em Return breadth-\/first iterator to the first node at a given depth. \end{DoxyCompactList}\item 
{\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf end\+\_\+breadth\+\_\+first} () const 
\begin{DoxyCompactList}\small\item\em Return breadth-\/first end iterator. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf begin} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Return sibling iterator to the first child of given node. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf end} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Return sibling end iterator for children of given node. \end{DoxyCompactList}\item 
{\bf leaf\+\_\+iterator} {\bf begin\+\_\+leaf} () const 
\begin{DoxyCompactList}\small\item\em Return leaf iterator to the first leaf of the tree. \end{DoxyCompactList}\item 
{\bf leaf\+\_\+iterator} {\bf end\+\_\+leaf} () const 
\begin{DoxyCompactList}\small\item\em Return leaf end iterator for entire tree. \end{DoxyCompactList}\item 
{\bf leaf\+\_\+iterator} {\bf begin\+\_\+leaf} (const {\bf iterator\+\_\+base} \&top) const 
\begin{DoxyCompactList}\small\item\em Return leaf iterator to the first leaf of the subtree at the given node. \end{DoxyCompactList}\item 
{\bf leaf\+\_\+iterator} {\bf end\+\_\+leaf} (const {\bf iterator\+\_\+base} \&top) const 
\begin{DoxyCompactList}\small\item\em Return leaf end iterator for the subtree at the given node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf previous\+\_\+sibling} (iter) const 
\begin{DoxyCompactList}\small\item\em Return iterator to the previous sibling of a node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf next\+\_\+sibling} (iter) const 
\begin{DoxyCompactList}\small\item\em Return iterator to the next sibling of a node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf next\+\_\+at\+\_\+same\+\_\+depth} (iter) const 
\begin{DoxyCompactList}\small\item\em Return iterator to the next node at a given depth. \end{DoxyCompactList}\item 
void {\bf clear} ()
\begin{DoxyCompactList}\small\item\em Erase all nodes of the tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf erase} (iter)
\begin{DoxyCompactList}\small\item\em Erase element at position pointed to by iterator, return incremented iterator. \end{DoxyCompactList}\item 
void {\bf erase\+\_\+children} (const {\bf iterator\+\_\+base} \&)
\begin{DoxyCompactList}\small\item\em Erase all children of the node pointed to by iterator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf append\+\_\+child} (iter position)
\begin{DoxyCompactList}\small\item\em Insert empty node as last/first child of node pointed to by position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf prepend\+\_\+child} (iter position)
\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf append\+\_\+child} (iter position, const T \&x)
\begin{DoxyCompactList}\small\item\em Insert node as last/first child of node pointed to by position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf prepend\+\_\+child} (iter position, const T \&x)
\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf append\+\_\+child} (iter position, iter other\+\_\+position)
\begin{DoxyCompactList}\small\item\em Append the node (plus its children) at other\+\_\+position as last/first child of position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf prepend\+\_\+child} (iter position, iter other\+\_\+position)
\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf append\+\_\+children} (iter position, {\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to)
\begin{DoxyCompactList}\small\item\em Append the nodes in the from-\/to range (plus their children) as last/first children of position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf prepend\+\_\+children} (iter position, {\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to)
\item 
{\bf pre\+\_\+order\+\_\+iterator} {\bf set\+\_\+head} (const T \&x)
\begin{DoxyCompactList}\small\item\em Short-\/hand to insert topmost node in otherwise empty tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf insert} (iter position, const T \&x)
\begin{DoxyCompactList}\small\item\em Insert node as previous sibling of node pointed to by position. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf insert} ({\bf sibling\+\_\+iterator} position, const T \&x)
\begin{DoxyCompactList}\small\item\em Specialisation of previous member. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf insert\+\_\+subtree} (iter position, const {\bf iterator\+\_\+base} \&{\bf subtree})
\begin{DoxyCompactList}\small\item\em Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf insert\+\_\+after} (iter position, const T \&x)
\begin{DoxyCompactList}\small\item\em Insert node as next sibling of node pointed to by position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf insert\+\_\+subtree\+\_\+after} (iter position, const {\bf iterator\+\_\+base} \&{\bf subtree})
\begin{DoxyCompactList}\small\item\em Insert node (with children) pointed to by subtree as next sibling of node pointed to by position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf replace} (iter position, const T \&x)
\begin{DoxyCompactList}\small\item\em Replace node at \textquotesingle{}position\textquotesingle{} with other node (keeping same children); \textquotesingle{}position\textquotesingle{} becomes invalid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf replace} (iter position, const {\bf iterator\+\_\+base} \&from)
\begin{DoxyCompactList}\small\item\em Replace node at \textquotesingle{}position\textquotesingle{} with subtree starting at \textquotesingle{}from\textquotesingle{} (do not erase subtree at \textquotesingle{}from\textquotesingle{}); see above. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf replace} ({\bf sibling\+\_\+iterator} orig\+\_\+begin, {\bf sibling\+\_\+iterator} orig\+\_\+end, {\bf sibling\+\_\+iterator} new\+\_\+begin, {\bf sibling\+\_\+iterator} new\+\_\+end)
\begin{DoxyCompactList}\small\item\em Replace string of siblings (plus their children) with copy of a new string (with children); see above. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf flatten} (iter position)
\begin{DoxyCompactList}\small\item\em Move all children of node at \textquotesingle{}position\textquotesingle{} to be siblings, returns position. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf reparent} (iter position, {\bf sibling\+\_\+iterator} {\bf begin}, {\bf sibling\+\_\+iterator} {\bf end})
\begin{DoxyCompactList}\small\item\em Move nodes in range to be children of \textquotesingle{}position\textquotesingle{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf reparent} (iter position, iter from)
\begin{DoxyCompactList}\small\item\em Move all child nodes of \textquotesingle{}from\textquotesingle{} to be children of \textquotesingle{}position\textquotesingle{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf wrap} (iter position, const T \&x)
\begin{DoxyCompactList}\small\item\em Replace node with a new node, making the old node a child of the new node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf move\+\_\+after} (iter target, iter source)
\begin{DoxyCompactList}\small\item\em Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the next sibling of \textquotesingle{}target\textquotesingle{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf move\+\_\+before} (iter target, iter source)
\begin{DoxyCompactList}\small\item\em Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the previous sibling of \textquotesingle{}target\textquotesingle{}. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf move\+\_\+before} ({\bf sibling\+\_\+iterator} target, {\bf sibling\+\_\+iterator} source)
\item 
{\footnotesize template$<$typename iter $>$ }\\iter {\bf move\+\_\+ontop} (iter target, iter source)
\begin{DoxyCompactList}\small\item\em Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the node at \textquotesingle{}target\textquotesingle{} (erasing the node at \textquotesingle{}target\textquotesingle{}). \end{DoxyCompactList}\item 
void {\bf merge} ({\bf sibling\+\_\+iterator}, {\bf sibling\+\_\+iterator}, {\bf sibling\+\_\+iterator}, {\bf sibling\+\_\+iterator}, bool duplicate\+\_\+leaves=false)
\begin{DoxyCompactList}\small\item\em Merge with other tree, creating new branches and leaves only if they are not already present. \end{DoxyCompactList}\item 
void {\bf sort} ({\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to, bool deep=false)
\begin{DoxyCompactList}\small\item\em Sort (std\+::sort only moves values of nodes, this one moves children as well). \end{DoxyCompactList}\item 
{\footnotesize template$<$class Strict\+Weak\+Ordering $>$ }\\void {\bf sort} ({\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to, Strict\+Weak\+Ordering comp, bool deep=false)
\item 
{\footnotesize template$<$typename iter $>$ }\\bool {\bf equal} (const iter \&one, const iter \&two, const iter \&three) const 
\begin{DoxyCompactList}\small\item\em Compare two ranges of nodes (compares nodes as well as tree structure). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename iter , class Binary\+Predicate $>$ }\\bool {\bf equal} (const iter \&one, const iter \&two, const iter \&three, Binary\+Predicate) const 
\item 
{\footnotesize template$<$typename iter $>$ }\\bool {\bf equal\+\_\+subtree} (const iter \&one, const iter \&two) const 
\item 
{\footnotesize template$<$typename iter , class Binary\+Predicate $>$ }\\bool {\bf equal\+\_\+subtree} (const iter \&one, const iter \&two, Binary\+Predicate) const 
\item 
{\bf tree} {\bf subtree} ({\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to) const 
\begin{DoxyCompactList}\small\item\em Extract a new tree formed by the range of siblings plus all their children. \end{DoxyCompactList}\item 
void {\bf subtree} ({\bf tree} \&, {\bf sibling\+\_\+iterator} from, {\bf sibling\+\_\+iterator} to) const 
\item 
void {\bf swap} ({\bf sibling\+\_\+iterator} it)
\begin{DoxyCompactList}\small\item\em Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). \end{DoxyCompactList}\item 
void {\bf swap} ({\bf iterator}, {\bf iterator})
\begin{DoxyCompactList}\small\item\em Exchange two nodes (plus subtrees) \end{DoxyCompactList}\item 
size\+\_\+t {\bf size} () const 
\begin{DoxyCompactList}\small\item\em Count the total number of nodes. \end{DoxyCompactList}\item 
size\+\_\+t {\bf size} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Count the total number of nodes below the indicated node (plus one). \end{DoxyCompactList}\item 
bool {\bf empty} () const 
\begin{DoxyCompactList}\small\item\em Check if tree is empty. \end{DoxyCompactList}\item 
int {\bf max\+\_\+depth} () const 
\begin{DoxyCompactList}\small\item\em Determine the maximal depth of the tree. An empty tree has max\+\_\+depth=-\/1. \end{DoxyCompactList}\item 
int {\bf max\+\_\+depth} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Determine the maximal depth of the tree with top node at the given position. \end{DoxyCompactList}\item 
unsigned int {\bf number\+\_\+of\+\_\+siblings} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Count the number of siblings (left and right) of node at iterator. Total nodes at this level is +1. \end{DoxyCompactList}\item 
bool {\bf is\+\_\+in\+\_\+subtree} (const {\bf iterator\+\_\+base} \&position, const {\bf iterator\+\_\+base} \&{\bf begin}, const {\bf iterator\+\_\+base} \&{\bf end}) const 
\begin{DoxyCompactList}\small\item\em Determine whether node at position is in the subtrees with root in the range. \end{DoxyCompactList}\item 
bool {\bf is\+\_\+valid} (const {\bf iterator\+\_\+base} \&) const 
\begin{DoxyCompactList}\small\item\em Determine whether the iterator is an \textquotesingle{}end\textquotesingle{} iterator and thus not actually pointing to a node. \end{DoxyCompactList}\item 
{\bf iterator} {\bf lowest\+\_\+common\+\_\+ancestor} (const {\bf iterator\+\_\+base} \&, const {\bf iterator\+\_\+base} \&) const 
\item 
unsigned int {\bf index} ({\bf sibling\+\_\+iterator} it) const 
\begin{DoxyCompactList}\small\item\em Determine the index of a node in the range of siblings to which it belongs. \end{DoxyCompactList}\item 
{\bf sibling\+\_\+iterator} {\bf sibling} (const {\bf iterator\+\_\+base} \&position, unsigned int)
\begin{DoxyCompactList}\small\item\em Return iterator to the sibling indicated by index. \end{DoxyCompactList}\item 
void {\bf debug\+\_\+verify\+\_\+consistency} () const 
\end{DoxyCompactItemize}
\subsection*{Métodos Públicos Estáticos}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename iter $>$ }\\static iter {\bf parent} (iter)
\begin{DoxyCompactList}\small\item\em Return iterator to the parent of a node. \end{DoxyCompactList}\item 
static int {\bf depth} (const {\bf iterator\+\_\+base} \&)
\begin{DoxyCompactList}\small\item\em Compute the depth to the root or to a fixed other iterator. \end{DoxyCompactList}\item 
static int {\bf depth} (const {\bf iterator\+\_\+base} \&, const {\bf iterator\+\_\+base} \&)
\item 
static unsigned int {\bf number\+\_\+of\+\_\+children} (const {\bf iterator\+\_\+base} \&)
\begin{DoxyCompactList}\small\item\em Count the number of children of node at position. \end{DoxyCompactList}\item 
static {\bf sibling\+\_\+iterator} {\bf child} (const {\bf iterator\+\_\+base} \&position, unsigned int)
\begin{DoxyCompactList}\small\item\em Inverse of \textquotesingle{}index\textquotesingle{}\+: return the n-\/th child of the node at position. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Atributos Públicos}
\begin{DoxyCompactItemize}
\item 
{\bf tree\+\_\+node} $\ast$ {\bf head}
\item 
{\bf tree\+\_\+node} $\ast$ {\bf feet}
\end{DoxyCompactItemize}
\subsection*{Tipos Protegidos}
\begin{DoxyCompactItemize}
\item 
typedef {\bf tree\+\_\+node\+\_\+}$<$ T $>$ {\bf tree\+\_\+node}
\end{DoxyCompactItemize}


\subsection{Descrição Detalhada}
\subsubsection*{template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$\\*
class tree$<$ T, tree\+\_\+node\+\_\+allocator $>$}



Definição na linha 67 do arquivo tree.\+h.



\subsection{Definições de Tipos}
\index{tree@{tree}!breadth\+\_\+first\+\_\+iterator@{breadth\+\_\+first\+\_\+iterator}}
\index{breadth\+\_\+first\+\_\+iterator@{breadth\+\_\+first\+\_\+iterator}!tree@{tree}}
\subsubsection[{breadth\+\_\+first\+\_\+iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ typedef {\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf breadth\+\_\+first\+\_\+iterator}}\label{classtree_a5f654926b4f16bd091931a08cc49d4c4}


Definição na linha 179 do arquivo tree.\+h.

\index{tree@{tree}!iterator@{iterator}}
\index{iterator@{iterator}!tree@{tree}}
\subsubsection[{iterator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ typedef {\bf pre\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf iterator}}\label{classtree_a2079982538b88d21fe1ccea34fe7ce0e}


The default iterator types throughout the tree class. 



Definição na linha 178 do arquivo tree.\+h.

\index{tree@{tree}!tree\+\_\+node@{tree\+\_\+node}}
\index{tree\+\_\+node@{tree\+\_\+node}!tree@{tree}}
\subsubsection[{tree\+\_\+node}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ typedef {\bf tree\+\_\+node\+\_\+}$<$T$>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf tree\+\_\+node}\hspace{0.3cm}{\ttfamily [protected]}}\label{classtree_a672d078d87ae97c58b732a940d7b8ca8}


Definição na linha 69 do arquivo tree.\+h.

\index{tree@{tree}!value\+\_\+type@{value\+\_\+type}}
\index{value\+\_\+type@{value\+\_\+type}!tree@{tree}}
\subsubsection[{value\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ typedef T {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf value\+\_\+type}}\label{classtree_a1e7bcd21e7420f7922a1bca79080acfa}


Value of the data stored at a node. 



Definição na linha 72 do arquivo tree.\+h.



\subsection{Construtores \& Destrutores}
\index{tree@{tree}!tree@{tree}}
\index{tree@{tree}!tree@{tree}}
\subsubsection[{tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classtree_aa064a1d9dceac9b918c5247919a4a325}


Definição na linha 477 do arquivo tree.\+h.

\index{tree@{tree}!tree@{tree}}
\index{tree@{tree}!tree@{tree}}
\subsubsection[{tree(const T \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf tree} (
\begin{DoxyParamCaption}
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_a5925c012af64fe91a3a5ed39e3ba9d9a}


Definição na linha 483 do arquivo tree.\+h.

\index{tree@{tree}!tree@{tree}}
\index{tree@{tree}!tree@{tree}}
\subsubsection[{tree(const iterator\+\_\+base \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf tree} (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{other}
\end{DoxyParamCaption}
)}\label{classtree_ab72378e7a772a82f90d91ef7493f27bc}


Definição na linha 490 do arquivo tree.\+h.

\index{tree@{tree}!tree@{tree}}
\index{tree@{tree}!tree@{tree}}
\subsubsection[{tree(const tree$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator$>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf tree} (
\begin{DoxyParamCaption}
\item[{const {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classtree_ae9e06b40929dfd33a1024bd422beedb6}


Definição na linha 537 do arquivo tree.\+h.

\index{tree@{tree}!````~tree@{$\sim$tree}}
\index{````~tree@{$\sim$tree}!tree@{tree}}
\subsubsection[{$\sim$tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::$\sim${\bf tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classtree_af0169b515c95f4299fd2d984137b7868}


Definição na linha 498 do arquivo tree.\+h.



\subsection{Métodos}
\index{tree@{tree}!append\+\_\+child@{append\+\_\+child}}
\index{append\+\_\+child@{append\+\_\+child}!tree@{tree}}
\subsubsection[{append\+\_\+child(iter position)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::append\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
)}\label{classtree_a989e89a62693299d3d7eb637957b040a}


Insert empty node as last/first child of node pointed to by position. 



Definição na linha 838 do arquivo tree.\+h.

\index{tree@{tree}!append\+\_\+child@{append\+\_\+child}}
\index{append\+\_\+child@{append\+\_\+child}!tree@{tree}}
\subsubsection[{append\+\_\+child(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::append\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_adfe8ab09c997fb7a23d27fa4be351386}


Insert node as last/first child of node pointed to by position. 



Definição na linha 892 do arquivo tree.\+h.

\index{tree@{tree}!append\+\_\+child@{append\+\_\+child}}
\index{append\+\_\+child@{append\+\_\+child}!tree@{tree}}
\subsubsection[{append\+\_\+child(iter position, iter other\+\_\+position)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::append\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{iter}]{other\+\_\+position}
\end{DoxyParamCaption}
)}\label{classtree_a91c383c68439af9e55a26a57ea927fac}


Append the node (plus its children) at other\+\_\+position as last/first child of position. 



Definição na linha 950 do arquivo tree.\+h.

\index{tree@{tree}!append\+\_\+children@{append\+\_\+children}}
\index{append\+\_\+children@{append\+\_\+children}!tree@{tree}}
\subsubsection[{append\+\_\+children(iter position, sibling\+\_\+iterator from, sibling\+\_\+iterator to)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::append\+\_\+children (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to}
\end{DoxyParamCaption}
)}\label{classtree_ab54b9862f3891737d6b4740d47dd9c68}


Append the nodes in the from-\/to range (plus their children) as last/first children of position. 



Definição na linha 974 do arquivo tree.\+h.

\index{tree@{tree}!begin@{begin}}
\index{begin@{begin}!tree@{tree}}
\subsubsection[{begin() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf pre\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classtree_a76b3a629c0208d5ae5b4ffcd4492e05e}


Return iterator to the beginning of the tree. 



Definição na linha 624 do arquivo tree.\+h.

\index{tree@{tree}!begin@{begin}}
\index{begin@{begin}!tree@{tree}}
\subsubsection[{begin(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{pos}
\end{DoxyParamCaption}
) const}\label{classtree_aa784ffa6dec85f52754dde8bd6a99aeb}


Return sibling iterator to the first child of given node. 



Definição na linha 714 do arquivo tree.\+h.

\index{tree@{tree}!begin\+\_\+breadth\+\_\+first@{begin\+\_\+breadth\+\_\+first}}
\index{begin\+\_\+breadth\+\_\+first@{begin\+\_\+breadth\+\_\+first}!tree@{tree}}
\subsubsection[{begin\+\_\+breadth\+\_\+first() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin\+\_\+breadth\+\_\+first (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a6277c20945f70549db84220146f5728a}


Return breadth-\/first iterator to the first node at a given depth. 



Definição na linha 636 do arquivo tree.\+h.

\index{tree@{tree}!begin\+\_\+fixed@{begin\+\_\+fixed}}
\index{begin\+\_\+fixed@{begin\+\_\+fixed}!tree@{tree}}
\subsubsection[{begin\+\_\+fixed(const iterator\+\_\+base \&, unsigned int) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf fixed\+\_\+depth\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin\+\_\+fixed (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{pos, }
\item[{unsigned int}]{dp}
\end{DoxyParamCaption}
) const}\label{classtree_a3e7ee34b9582cb6f0bd5b25f501a1057}


Return fixed-\/depth iterator to the first node at a given depth from the given iterator. 



Definição na linha 665 do arquivo tree.\+h.

\index{tree@{tree}!begin\+\_\+leaf@{begin\+\_\+leaf}}
\index{begin\+\_\+leaf@{begin\+\_\+leaf}!tree@{tree}}
\subsubsection[{begin\+\_\+leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf leaf\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin\+\_\+leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a9069949485f75bf9c0e8c7606e0ab12e}


Return leaf iterator to the first leaf of the tree. 



Definição na linha 732 do arquivo tree.\+h.

\index{tree@{tree}!begin\+\_\+leaf@{begin\+\_\+leaf}}
\index{begin\+\_\+leaf@{begin\+\_\+leaf}!tree@{tree}}
\subsubsection[{begin\+\_\+leaf(const iterator\+\_\+base \&top) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf leaf\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin\+\_\+leaf (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{top}
\end{DoxyParamCaption}
) const}\label{classtree_afa706e56797241e392f65d1c1e92f1d6}


Return leaf iterator to the first leaf of the subtree at the given node. 



Definição na linha 749 do arquivo tree.\+h.

\index{tree@{tree}!begin\+\_\+post@{begin\+\_\+post}}
\index{begin\+\_\+post@{begin\+\_\+post}!tree@{tree}}
\subsubsection[{begin\+\_\+post() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf post\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::begin\+\_\+post (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a73c673d39fe46db7ca4e1533841cdbc0}


Return post-\/order iterator to the beginning of the tree. 



Definição na linha 648 do arquivo tree.\+h.

\index{tree@{tree}!child@{child}}
\index{child@{child}!tree@{tree}}
\subsubsection[{child(const iterator\+\_\+base \&position, unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::child (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{position, }
\item[{unsigned int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classtree_a8cdd97ca2dca227851370d97120ab0ef}


Inverse of \textquotesingle{}index\textquotesingle{}\+: return the n-\/th child of the node at position. 



Definição na linha 1943 do arquivo tree.\+h.

\index{tree@{tree}!clear@{clear}}
\index{clear@{clear}!tree@{tree}}
\subsubsection[{clear()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classtree_aa8cf6dfe17504abfc0ffabb5a4ba9d0a}


Erase all nodes of the tree. 



Definição na linha 565 do arquivo tree.\+h.

\index{tree@{tree}!debug\+\_\+verify\+\_\+consistency@{debug\+\_\+verify\+\_\+consistency}}
\index{debug\+\_\+verify\+\_\+consistency@{debug\+\_\+verify\+\_\+consistency}!tree@{tree}}
\subsubsection[{debug\+\_\+verify\+\_\+consistency() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::debug\+\_\+verify\+\_\+consistency (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a11c7104053f8d813b350f8c45f03f402}
For debugging only\+: verify internal consistency by inspecting all pointers in the tree (which will also trigger a valgrind error in case something got corrupted). 

Definição na linha 1924 do arquivo tree.\+h.

\index{tree@{tree}!depth@{depth}}
\index{depth@{depth}!tree@{tree}}
\subsubsection[{depth(const iterator\+\_\+base \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::depth (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classtree_abd2cda449681989ae39b78496b20d337}


Compute the depth to the root or to a fixed other iterator. 



Definição na linha 1667 do arquivo tree.\+h.

\index{tree@{tree}!depth@{depth}}
\index{depth@{depth}!tree@{tree}}
\subsubsection[{depth(const iterator\+\_\+base \&, const iterator\+\_\+base \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::depth (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it, }
\item[{const {\bf iterator\+\_\+base} \&}]{root}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classtree_a17a55a32e0d4fa30ed8e813f8bd26483}


Definição na linha 1680 do arquivo tree.\+h.

\index{tree@{tree}!empty@{empty}}
\index{empty@{empty}!tree@{tree}}
\subsubsection[{empty() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_ae9f7fd30c51443d46ca8941d5bc06da2}


Check if tree is empty. 



Definição na linha 1660 do arquivo tree.\+h.

\index{tree@{tree}!end@{end}}
\index{end@{end}!tree@{tree}}
\subsubsection[{end() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf pre\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classtree_a0d09fe9fd34fbfc9c9e4e28cb694448e}


Return iterator to the end of the tree. 



Definição na linha 630 do arquivo tree.\+h.

\index{tree@{tree}!end@{end}}
\index{end@{end}!tree@{tree}}
\subsubsection[{end(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{pos}
\end{DoxyParamCaption}
) const}\label{classtree_aa6aa8b0c6af0f50bfc86592847759127}


Return sibling end iterator for children of given node. 



Definição na linha 724 do arquivo tree.\+h.

\index{tree@{tree}!end\+\_\+breadth\+\_\+first@{end\+\_\+breadth\+\_\+first}}
\index{end\+\_\+breadth\+\_\+first@{end\+\_\+breadth\+\_\+first}!tree@{tree}}
\subsubsection[{end\+\_\+breadth\+\_\+first() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf breadth\+\_\+first\+\_\+queued\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end\+\_\+breadth\+\_\+first (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a20aff0c93474788bd7cc0951a778f9ff}


Return breadth-\/first end iterator. 



Definição na linha 642 do arquivo tree.\+h.

\index{tree@{tree}!end\+\_\+fixed@{end\+\_\+fixed}}
\index{end\+\_\+fixed@{end\+\_\+fixed}!tree@{tree}}
\subsubsection[{end\+\_\+fixed(const iterator\+\_\+base \&, unsigned int) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf fixed\+\_\+depth\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end\+\_\+fixed (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{pos, }
\item[{unsigned int}]{dp}
\end{DoxyParamCaption}
) const}\label{classtree_abab26c0edd25cc836ed768e32c034165}


Return fixed-\/depth end iterator. 



Definição na linha 696 do arquivo tree.\+h.

\index{tree@{tree}!end\+\_\+leaf@{end\+\_\+leaf}}
\index{end\+\_\+leaf@{end\+\_\+leaf}!tree@{tree}}
\subsubsection[{end\+\_\+leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf leaf\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end\+\_\+leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a9fbca20225d8684b8fa3ce131591ca7a}


Return leaf end iterator for entire tree. 



Definição na linha 743 do arquivo tree.\+h.

\index{tree@{tree}!end\+\_\+leaf@{end\+\_\+leaf}}
\index{end\+\_\+leaf@{end\+\_\+leaf}!tree@{tree}}
\subsubsection[{end\+\_\+leaf(const iterator\+\_\+base \&top) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf leaf\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end\+\_\+leaf (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{top}
\end{DoxyParamCaption}
) const}\label{classtree_a1645d0047c04e416d826d3d3fe408629}


Return leaf end iterator for the subtree at the given node. 



Definição na linha 758 do arquivo tree.\+h.

\index{tree@{tree}!end\+\_\+post@{end\+\_\+post}}
\index{end\+\_\+post@{end\+\_\+post}!tree@{tree}}
\subsubsection[{end\+\_\+post() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf post\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::end\+\_\+post (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_ad339ab550fc2718e84506e91960a177f}


Return post-\/order end iterator of the tree. 



Definição na linha 659 do arquivo tree.\+h.

\index{tree@{tree}!equal@{equal}}
\index{equal@{equal}!tree@{tree}}
\subsubsection[{equal(const iter \&one, const iter \&two, const iter \&three) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::equal (
\begin{DoxyParamCaption}
\item[{const iter \&}]{one, }
\item[{const iter \&}]{two, }
\item[{const iter \&}]{three}
\end{DoxyParamCaption}
) const}\label{classtree_a4bf8bcacc72562ef00d742b2ba6d03fb}


Compare two ranges of nodes (compares nodes as well as tree structure). 



Definição na linha 1573 do arquivo tree.\+h.

\index{tree@{tree}!equal@{equal}}
\index{equal@{equal}!tree@{tree}}
\subsubsection[{equal(const iter \&one, const iter \&two, const iter \&three, Binary\+Predicate) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter , class Binary\+Predicate $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::equal (
\begin{DoxyParamCaption}
\item[{const iter \&}]{one, }
\item[{const iter \&}]{two, }
\item[{const iter \&}]{three, }
\item[{Binary\+Predicate}]{fun}
\end{DoxyParamCaption}
) const}\label{classtree_ab655b544d938ebea0aed91810be3dd23}


Definição na linha 1589 do arquivo tree.\+h.

\index{tree@{tree}!equal\+\_\+subtree@{equal\+\_\+subtree}}
\index{equal\+\_\+subtree@{equal\+\_\+subtree}!tree@{tree}}
\subsubsection[{equal\+\_\+subtree(const iter \&one, const iter \&two) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::equal\+\_\+subtree (
\begin{DoxyParamCaption}
\item[{const iter \&}]{one, }
\item[{const iter \&}]{two}
\end{DoxyParamCaption}
) const}\label{classtree_a9cb7b1a526f1865bcd1675376509a4cb}


Definição na linha 1581 do arquivo tree.\+h.

\index{tree@{tree}!equal\+\_\+subtree@{equal\+\_\+subtree}}
\index{equal\+\_\+subtree@{equal\+\_\+subtree}!tree@{tree}}
\subsubsection[{equal\+\_\+subtree(const iter \&one, const iter \&two, Binary\+Predicate) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter , class Binary\+Predicate $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::equal\+\_\+subtree (
\begin{DoxyParamCaption}
\item[{const iter \&}]{one, }
\item[{const iter \&}]{two, }
\item[{Binary\+Predicate}]{fun}
\end{DoxyParamCaption}
) const}\label{classtree_a275cc39b461e0c76256db19bdbbd5a81}


Definição na linha 1608 do arquivo tree.\+h.

\index{tree@{tree}!erase@{erase}}
\index{erase@{erase}!tree@{tree}}
\subsubsection[{erase(iter)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::erase (
\begin{DoxyParamCaption}
\item[{iter}]{it}
\end{DoxyParamCaption}
)}\label{classtree_af7978c72a08d31a88d068403ce762957}


Erase element at position pointed to by iterator, return incremented iterator. 



Definição na linha 596 do arquivo tree.\+h.

\index{tree@{tree}!erase\+\_\+children@{erase\+\_\+children}}
\index{erase\+\_\+children@{erase\+\_\+children}!tree@{tree}}
\subsubsection[{erase\+\_\+children(const iterator\+\_\+base \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::erase\+\_\+children (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it}
\end{DoxyParamCaption}
)}\label{classtree_a05d5fd71c206efc8ac30df5cd46176bc}


Erase all children of the node pointed to by iterator. 



Definição na linha 573 do arquivo tree.\+h.

\index{tree@{tree}!flatten@{flatten}}
\index{flatten@{flatten}!tree@{tree}}
\subsubsection[{flatten(iter position)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::flatten (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
)}\label{classtree_af22f206f80a58442738eafe81d15d90f}


Move all children of node at \textquotesingle{}position\textquotesingle{} to be siblings, returns position. 



Definição na linha 1252 do arquivo tree.\+h.

\index{tree@{tree}!index@{index}}
\index{index@{index}!tree@{tree}}
\subsubsection[{index(sibling\+\_\+iterator it) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ unsigned int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::index (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{it}
\end{DoxyParamCaption}
) const}\label{classtree_ade5ec1ba55f94165062e50d01ec35d86}


Determine the index of a node in the range of siblings to which it belongs. 



Definição na linha 1883 do arquivo tree.\+h.

\index{tree@{tree}!insert@{insert}}
\index{insert@{insert}!tree@{tree}}
\subsubsection[{insert(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::insert (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_abd3877aa257981dabf6c77343690e802}


Insert node as previous sibling of node pointed to by position. 



Definição na linha 1015 do arquivo tree.\+h.

\index{tree@{tree}!insert@{insert}}
\index{insert@{insert}!tree@{tree}}
\subsubsection[{insert(sibling\+\_\+iterator position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::insert (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_a429bbd485078981ef83b59a779d9f947}


Specialisation of previous member. 



Definição na linha 1042 do arquivo tree.\+h.

\index{tree@{tree}!insert\+\_\+after@{insert\+\_\+after}}
\index{insert\+\_\+after@{insert\+\_\+after}!tree@{tree}}
\subsubsection[{insert\+\_\+after(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::insert\+\_\+after (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_a24d2bd78776bc659863a548013329c5e}


Insert node as next sibling of node pointed to by position. 



Definição na linha 1073 do arquivo tree.\+h.

\index{tree@{tree}!insert\+\_\+subtree@{insert\+\_\+subtree}}
\index{insert\+\_\+subtree@{insert\+\_\+subtree}!tree@{tree}}
\subsubsection[{insert\+\_\+subtree(iter position, const iterator\+\_\+base \&subtree)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::insert\+\_\+subtree (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const {\bf iterator\+\_\+base} \&}]{subtree}
\end{DoxyParamCaption}
)}\label{classtree_a683dda6a81ce1e22f93db0feed0a9104}


Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. 



Definição na linha 1098 do arquivo tree.\+h.

\index{tree@{tree}!insert\+\_\+subtree\+\_\+after@{insert\+\_\+subtree\+\_\+after}}
\index{insert\+\_\+subtree\+\_\+after@{insert\+\_\+subtree\+\_\+after}!tree@{tree}}
\subsubsection[{insert\+\_\+subtree\+\_\+after(iter position, const iterator\+\_\+base \&subtree)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::insert\+\_\+subtree\+\_\+after (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const {\bf iterator\+\_\+base} \&}]{subtree}
\end{DoxyParamCaption}
)}\label{classtree_a68d8330dd25bc779fef9ccc19d37c7ac}


Insert node (with children) pointed to by subtree as next sibling of node pointed to by position. 



Definição na linha 1108 do arquivo tree.\+h.

\index{tree@{tree}!is\+\_\+in\+\_\+subtree@{is\+\_\+in\+\_\+subtree}}
\index{is\+\_\+in\+\_\+subtree@{is\+\_\+in\+\_\+subtree}!tree@{tree}}
\subsubsection[{is\+\_\+in\+\_\+subtree(const iterator\+\_\+base \&position, const iterator\+\_\+base \&begin, const iterator\+\_\+base \&end) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::is\+\_\+in\+\_\+subtree (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{position, }
\item[{const {\bf iterator\+\_\+base} \&}]{begin, }
\item[{const {\bf iterator\+\_\+base} \&}]{end}
\end{DoxyParamCaption}
) const}\label{classtree_a825e2106781e846bdd8732c117dc21db}


Determine whether node at position is in the subtrees with root in the range. 



Definição na linha 1840 do arquivo tree.\+h.

\index{tree@{tree}!is\+\_\+valid@{is\+\_\+valid}}
\index{is\+\_\+valid@{is\+\_\+valid}!tree@{tree}}
\subsubsection[{is\+\_\+valid(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ bool {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::is\+\_\+valid (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it}
\end{DoxyParamCaption}
) const}\label{classtree_a9605b028195248894dc8cf506cd256e3}


Determine whether the iterator is an \textquotesingle{}end\textquotesingle{} iterator and thus not actually pointing to a node. 



Definição na linha 1853 do arquivo tree.\+h.

\index{tree@{tree}!lowest\+\_\+common\+\_\+ancestor@{lowest\+\_\+common\+\_\+ancestor}}
\index{lowest\+\_\+common\+\_\+ancestor@{lowest\+\_\+common\+\_\+ancestor}!tree@{tree}}
\subsubsection[{lowest\+\_\+common\+\_\+ancestor(const iterator\+\_\+base \&, const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::lowest\+\_\+common\+\_\+ancestor (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{one, }
\item[{const {\bf iterator\+\_\+base} \&}]{two}
\end{DoxyParamCaption}
) const}\label{classtree_add52cb71c4d009647baae275b6ce7a28}
Find the lowest common ancestor of two nodes, that is, the deepest node such that both nodes are descendants of it. 

Definição na linha 1860 do arquivo tree.\+h.

\index{tree@{tree}!max\+\_\+depth@{max\+\_\+depth}}
\index{max\+\_\+depth@{max\+\_\+depth}!tree@{tree}}
\subsubsection[{max\+\_\+depth() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::max\+\_\+depth (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_af255c884d0614534536e07f2efec842f}


Determine the maximal depth of the tree. An empty tree has max\+\_\+depth=-\/1. 



Definição na linha 1693 do arquivo tree.\+h.

\index{tree@{tree}!max\+\_\+depth@{max\+\_\+depth}}
\index{max\+\_\+depth@{max\+\_\+depth}!tree@{tree}}
\subsubsection[{max\+\_\+depth(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::max\+\_\+depth (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{pos}
\end{DoxyParamCaption}
) const}\label{classtree_ad3cdd5477d90cb008ac75aacbf81520b}


Determine the maximal depth of the tree with top node at the given position. 



Definição na linha 1704 do arquivo tree.\+h.

\index{tree@{tree}!merge@{merge}}
\index{merge@{merge}!tree@{tree}}
\subsubsection[{merge(sibling\+\_\+iterator, sibling\+\_\+iterator, sibling\+\_\+iterator, sibling\+\_\+iterator, bool duplicate\+\_\+leaves=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::merge (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{to1, }
\item[{{\bf sibling\+\_\+iterator}}]{to2, }
\item[{{\bf sibling\+\_\+iterator}}]{from1, }
\item[{{\bf sibling\+\_\+iterator}}]{from2, }
\item[{bool}]{duplicate\+\_\+leaves = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classtree_a1e3cd901f8f8d8a3da0e1d32e9282db1}


Merge with other tree, creating new branches and leaves only if they are not already present. 



Definição na linha 1481 do arquivo tree.\+h.

\index{tree@{tree}!move\+\_\+after@{move\+\_\+after}}
\index{move\+\_\+after@{move\+\_\+after}!tree@{tree}}
\subsubsection[{move\+\_\+after(iter target, iter source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::move\+\_\+after (
\begin{DoxyParamCaption}
\item[{iter}]{target, }
\item[{iter}]{source}
\end{DoxyParamCaption}
)}\label{classtree_ab448c9d3e6388b80f9586a5c9f4af47e}


Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the next sibling of \textquotesingle{}target\textquotesingle{}. 



Definição na linha 1346 do arquivo tree.\+h.

\index{tree@{tree}!move\+\_\+before@{move\+\_\+before}}
\index{move\+\_\+before@{move\+\_\+before}!tree@{tree}}
\subsubsection[{move\+\_\+before(iter target, iter source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::move\+\_\+before (
\begin{DoxyParamCaption}
\item[{iter}]{target, }
\item[{iter}]{source}
\end{DoxyParamCaption}
)}\label{classtree_afe6d1527ccc394937c1cc41ab4850bcf}


Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the previous sibling of \textquotesingle{}target\textquotesingle{}. 



Definição na linha 1375 do arquivo tree.\+h.

\index{tree@{tree}!move\+\_\+before@{move\+\_\+before}}
\index{move\+\_\+before@{move\+\_\+before}!tree@{tree}}
\subsubsection[{move\+\_\+before(sibling\+\_\+iterator target, sibling\+\_\+iterator source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::move\+\_\+before (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{target, }
\item[{{\bf sibling\+\_\+iterator}}]{source}
\end{DoxyParamCaption}
)}\label{classtree_a3059d1ed201f2ec828ac4829ade400c2}


Definição na linha 1405 do arquivo tree.\+h.

\index{tree@{tree}!move\+\_\+ontop@{move\+\_\+ontop}}
\index{move\+\_\+ontop@{move\+\_\+ontop}!tree@{tree}}
\subsubsection[{move\+\_\+ontop(iter target, iter source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::move\+\_\+ontop (
\begin{DoxyParamCaption}
\item[{iter}]{target, }
\item[{iter}]{source}
\end{DoxyParamCaption}
)}\label{classtree_a32e2ff253b76486cee84b40737604bf8}


Move \textquotesingle{}source\textquotesingle{} node (plus its children) to become the node at \textquotesingle{}target\textquotesingle{} (erasing the node at \textquotesingle{}target\textquotesingle{}). 



Definição na linha 1442 do arquivo tree.\+h.

\index{tree@{tree}!next\+\_\+at\+\_\+same\+\_\+depth@{next\+\_\+at\+\_\+same\+\_\+depth}}
\index{next\+\_\+at\+\_\+same\+\_\+depth@{next\+\_\+at\+\_\+same\+\_\+depth}!tree@{tree}}
\subsubsection[{next\+\_\+at\+\_\+same\+\_\+depth(iter) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::next\+\_\+at\+\_\+same\+\_\+depth (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
) const}\label{classtree_a0359044f9fd4422041b6b46abd0ca7c3}


Return iterator to the next node at a given depth. 



Definição na linha 793 do arquivo tree.\+h.

\index{tree@{tree}!next\+\_\+sibling@{next\+\_\+sibling}}
\index{next\+\_\+sibling@{next\+\_\+sibling}!tree@{tree}}
\subsubsection[{next\+\_\+sibling(iter) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::next\+\_\+sibling (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
) const}\label{classtree_a0dd60c951b373d737fe8336308df7561}


Return iterator to the next sibling of a node. 



Definição na linha 783 do arquivo tree.\+h.

\index{tree@{tree}!number\+\_\+of\+\_\+children@{number\+\_\+of\+\_\+children}}
\index{number\+\_\+of\+\_\+children@{number\+\_\+of\+\_\+children}!tree@{tree}}
\subsubsection[{number\+\_\+of\+\_\+children(const iterator\+\_\+base \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ unsigned int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::number\+\_\+of\+\_\+children (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classtree_a23d99b3de4f3752f6e040923adb54424}


Count the number of children of node at position. 



Definição na linha 1732 do arquivo tree.\+h.

\index{tree@{tree}!number\+\_\+of\+\_\+siblings@{number\+\_\+of\+\_\+siblings}}
\index{number\+\_\+of\+\_\+siblings@{number\+\_\+of\+\_\+siblings}!tree@{tree}}
\subsubsection[{number\+\_\+of\+\_\+siblings(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ unsigned int {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::number\+\_\+of\+\_\+siblings (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{it}
\end{DoxyParamCaption}
) const}\label{classtree_a3cddce970c4d44af57cf9ec0d7c3d009}


Count the number of siblings (left and right) of node at iterator. Total nodes at this level is +1. 



Definição na linha 1748 do arquivo tree.\+h.

\index{tree@{tree}!operator=@{operator=}}
\index{operator=@{operator=}!tree@{tree}}
\subsubsection[{operator=(const tree$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator$>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \& {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classtree_aef262f4474b92e83e963a3d72abfb10a}


Definição na linha 529 do arquivo tree.\+h.

\index{tree@{tree}!parent@{parent}}
\index{parent@{parent}!tree@{tree}}
\subsubsection[{parent(iter)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::parent (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classtree_a450520d59f3d548a0f5a594571efd304}


Return iterator to the parent of a node. 



Definição na linha 765 do arquivo tree.\+h.

\index{tree@{tree}!prepend\+\_\+child@{prepend\+\_\+child}}
\index{prepend\+\_\+child@{prepend\+\_\+child}!tree@{tree}}
\subsubsection[{prepend\+\_\+child(iter position)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::prepend\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
)}\label{classtree_aa0d0fb11d97ad48314fae6ccccdf26bf}


Definição na linha 865 do arquivo tree.\+h.

\index{tree@{tree}!prepend\+\_\+child@{prepend\+\_\+child}}
\index{prepend\+\_\+child@{prepend\+\_\+child}!tree@{tree}}
\subsubsection[{prepend\+\_\+child(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::prepend\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_a9dc99bfe1c1fbd24e0bcb3a265438034}


Definição na linha 923 do arquivo tree.\+h.

\index{tree@{tree}!prepend\+\_\+child@{prepend\+\_\+child}}
\index{prepend\+\_\+child@{prepend\+\_\+child}!tree@{tree}}
\subsubsection[{prepend\+\_\+child(iter position, iter other\+\_\+position)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::prepend\+\_\+child (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{iter}]{other\+\_\+position}
\end{DoxyParamCaption}
)}\label{classtree_adadca03c1d831a97414a8e033035f01a}


Definição na linha 962 do arquivo tree.\+h.

\index{tree@{tree}!prepend\+\_\+children@{prepend\+\_\+children}}
\index{prepend\+\_\+children@{prepend\+\_\+children}!tree@{tree}}
\subsubsection[{prepend\+\_\+children(iter position, sibling\+\_\+iterator from, sibling\+\_\+iterator to)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::prepend\+\_\+children (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to}
\end{DoxyParamCaption}
)}\label{classtree_aaf01873bc5f94464ab156bffa34ed079}


Definição na linha 991 do arquivo tree.\+h.

\index{tree@{tree}!previous\+\_\+sibling@{previous\+\_\+sibling}}
\index{previous\+\_\+sibling@{previous\+\_\+sibling}!tree@{tree}}
\subsubsection[{previous\+\_\+sibling(iter) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::previous\+\_\+sibling (
\begin{DoxyParamCaption}
\item[{iter}]{position}
\end{DoxyParamCaption}
) const}\label{classtree_a4fcd360b58ad435a4c100104e05942cc}


Return iterator to the previous sibling of a node. 



Definição na linha 773 do arquivo tree.\+h.

\index{tree@{tree}!reparent@{reparent}}
\index{reparent@{reparent}!tree@{tree}}
\subsubsection[{reparent(iter position, sibling\+\_\+iterator begin, sibling\+\_\+iterator end)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::reparent (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{{\bf sibling\+\_\+iterator}}]{begin, }
\item[{{\bf sibling\+\_\+iterator}}]{end}
\end{DoxyParamCaption}
)}\label{classtree_ae1ba1b04978de8758f231e2e81b609e5}


Move nodes in range to be children of \textquotesingle{}position\textquotesingle{}. 



Definição na linha 1280 do arquivo tree.\+h.

\index{tree@{tree}!reparent@{reparent}}
\index{reparent@{reparent}!tree@{tree}}
\subsubsection[{reparent(iter position, iter from)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::reparent (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{iter}]{from}
\end{DoxyParamCaption}
)}\label{classtree_a748532ca50c5e2ffecae79663d77f5ed}


Move all child nodes of \textquotesingle{}from\textquotesingle{} to be children of \textquotesingle{}position\textquotesingle{}. 



Definição na linha 1328 do arquivo tree.\+h.

\index{tree@{tree}!replace@{replace}}
\index{replace@{replace}!tree@{tree}}
\subsubsection[{replace(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::replace (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_ab090190d800c8bdf32535f8aa8857949}


Replace node at \textquotesingle{}position\textquotesingle{} with other node (keeping same children); \textquotesingle{}position\textquotesingle{} becomes invalid. 



Definição na linha 1128 do arquivo tree.\+h.

\index{tree@{tree}!replace@{replace}}
\index{replace@{replace}!tree@{tree}}
\subsubsection[{replace(iter position, const iterator\+\_\+base \&from)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$class iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::replace (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const {\bf iterator\+\_\+base} \&}]{from}
\end{DoxyParamCaption}
)}\label{classtree_af313f7b5e83bf9b42eb56384e057316e}


Replace node at \textquotesingle{}position\textquotesingle{} with subtree starting at \textquotesingle{}from\textquotesingle{} (do not erase subtree at \textquotesingle{}from\textquotesingle{}); see above. 



Definição na linha 1140 do arquivo tree.\+h.

\index{tree@{tree}!replace@{replace}}
\index{replace@{replace}!tree@{tree}}
\subsubsection[{replace(sibling\+\_\+iterator orig\+\_\+begin, sibling\+\_\+iterator orig\+\_\+end, sibling\+\_\+iterator new\+\_\+begin, sibling\+\_\+iterator new\+\_\+end)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::replace (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{orig\+\_\+begin, }
\item[{{\bf sibling\+\_\+iterator}}]{orig\+\_\+end, }
\item[{{\bf sibling\+\_\+iterator}}]{new\+\_\+begin, }
\item[{{\bf sibling\+\_\+iterator}}]{new\+\_\+end}
\end{DoxyParamCaption}
)}\label{classtree_afc5bef13996f2fd939d83837aa8e090d}


Replace string of siblings (plus their children) with copy of a new string (with children); see above. 



Definição na linha 1206 do arquivo tree.\+h.

\index{tree@{tree}!set\+\_\+head@{set\+\_\+head}}
\index{set\+\_\+head@{set\+\_\+head}!tree@{tree}}
\subsubsection[{set\+\_\+head(const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf pre\+\_\+order\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::set\+\_\+head (
\begin{DoxyParamCaption}
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_af11d736ea971ab93651350161f5a7535}


Short-\/hand to insert topmost node in otherwise empty tree. 



Definição na linha 1007 do arquivo tree.\+h.

\index{tree@{tree}!sibling@{sibling}}
\index{sibling@{sibling}!tree@{tree}}
\subsubsection[{sibling(const iterator\+\_\+base \&position, unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::{\bf sibling\+\_\+iterator} {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::sibling (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{position, }
\item[{unsigned int}]{num}
\end{DoxyParamCaption}
)}\label{classtree_a02a9dd5a8f79e01137fe7d9f1f8b76b7}


Return iterator to the sibling indicated by index. 



Definição na linha 1902 do arquivo tree.\+h.

\index{tree@{tree}!size@{size}}
\index{size@{size}!tree@{tree}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ size\+\_\+t {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classtree_a68ad599f29cc97cfb36259097c19b7ca}


Count the total number of nodes. 



Definição na linha 1634 do arquivo tree.\+h.

\index{tree@{tree}!size@{size}}
\index{size@{size}!tree@{tree}}
\subsubsection[{size(const iterator\+\_\+base \&) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ size\+\_\+t {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::size (
\begin{DoxyParamCaption}
\item[{const {\bf iterator\+\_\+base} \&}]{top}
\end{DoxyParamCaption}
) const}\label{classtree_aa6a74bd0399c99f7cc7459f996200f8a}


Count the total number of nodes below the indicated node (plus one). 



Definição na linha 1646 do arquivo tree.\+h.

\index{tree@{tree}!sort@{sort}}
\index{sort@{sort}!tree@{tree}}
\subsubsection[{sort(sibling\+\_\+iterator from, sibling\+\_\+iterator to, bool deep=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::sort (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to, }
\item[{bool}]{deep = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classtree_a498ec42a5eb44cba8bf9ef6e7fd5db9e}


Sort (std\+::sort only moves values of nodes, this one moves children as well). 



Definição na linha 1505 do arquivo tree.\+h.

\index{tree@{tree}!sort@{sort}}
\index{sort@{sort}!tree@{tree}}
\subsubsection[{sort(sibling\+\_\+iterator from, sibling\+\_\+iterator to, Strict\+Weak\+Ordering comp, bool deep=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ template$<$class Strict\+Weak\+Ordering $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::sort (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to, }
\item[{Strict\+Weak\+Ordering}]{comp, }
\item[{bool}]{deep = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classtree_a2a304316640301e8ac99424fe64f8817}


Definição na linha 1513 do arquivo tree.\+h.

\index{tree@{tree}!subtree@{subtree}}
\index{subtree@{subtree}!tree@{tree}}
\subsubsection[{subtree(sibling\+\_\+iterator from, sibling\+\_\+iterator to) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::subtree (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to}
\end{DoxyParamCaption}
) const}\label{classtree_adb61bebed6c56eb5641b0b7fab7fe625}


Extract a new tree formed by the range of siblings plus all their children. 



Definição na linha 1618 do arquivo tree.\+h.

\index{tree@{tree}!subtree@{subtree}}
\index{subtree@{subtree}!tree@{tree}}
\subsubsection[{subtree(tree \&, sibling\+\_\+iterator from, sibling\+\_\+iterator to) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::subtree (
\begin{DoxyParamCaption}
\item[{{\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$ \&}]{tmp, }
\item[{{\bf sibling\+\_\+iterator}}]{from, }
\item[{{\bf sibling\+\_\+iterator}}]{to}
\end{DoxyParamCaption}
) const}\label{classtree_a830cccac50df183c44c6ff83cab5a27f}


Definição na linha 1627 do arquivo tree.\+h.

\index{tree@{tree}!swap@{swap}}
\index{swap@{swap}!tree@{tree}}
\subsubsection[{swap(sibling\+\_\+iterator it)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::swap (
\begin{DoxyParamCaption}
\item[{{\bf sibling\+\_\+iterator}}]{it}
\end{DoxyParamCaption}
)}\label{classtree_ae842f9b70235bc2412b3c43bca759448}


Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). 



Definição na linha 1772 do arquivo tree.\+h.

\index{tree@{tree}!swap@{swap}}
\index{swap@{swap}!tree@{tree}}
\subsubsection[{swap(iterator, iterator)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class tree\+\_\+node\+\_\+allocator $>$ void {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::swap (
\begin{DoxyParamCaption}
\item[{{\bf iterator}}]{one, }
\item[{{\bf iterator}}]{two}
\end{DoxyParamCaption}
)}\label{classtree_adc67ebdd1db6d695f66f919fa0debbd9}


Exchange two nodes (plus subtrees) 



Definição na linha 1793 do arquivo tree.\+h.

\index{tree@{tree}!wrap@{wrap}}
\index{wrap@{wrap}!tree@{tree}}
\subsubsection[{wrap(iter position, const T \&x)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator $>$ template$<$typename iter $>$ iter {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::wrap (
\begin{DoxyParamCaption}
\item[{iter}]{position, }
\item[{const T \&}]{x}
\end{DoxyParamCaption}
)}\label{classtree_aa6460c1d8ad7508b10d5496cdc8b6f2f}


Replace node with a new node, making the old node a child of the new node. 



Definição na linha 1335 do arquivo tree.\+h.



\subsection{Atributos}
\index{tree@{tree}!feet@{feet}}
\index{feet@{feet}!tree@{tree}}
\subsubsection[{feet}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ {\bf tree\+\_\+node} $\ast$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::feet}\label{classtree_ae1dbb80115ba483e37d081a2256c239b}


Definição na linha 413 do arquivo tree.\+h.

\index{tree@{tree}!head@{head}}
\index{head@{head}!tree@{tree}}
\subsubsection[{head}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T, class tree\+\_\+node\+\_\+allocator = std\+::allocator$<$tree\+\_\+node\+\_\+$<$\+T$>$ $>$$>$ {\bf tree\+\_\+node}$\ast$ {\bf tree}$<$ T, tree\+\_\+node\+\_\+allocator $>$\+::head}\label{classtree_a10991cbf1497e125c0ef04d6e292e32b}


Definição na linha 413 do arquivo tree.\+h.



A documentação para esta classe foi gerada a partir do seguinte arquivo\+:\begin{DoxyCompactItemize}
\item 
{\bf tree.\+h}\end{DoxyCompactItemize}
